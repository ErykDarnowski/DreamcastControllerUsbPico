
; NOTES:
; - It is up to the program to ensure open line before activating this
; - Since bytes are shifted out "to the left" in order to shift out the most significant bit of each
;   byte first, the most significant byte comes out first too. This means byte order will need to be
;   swapped before feeding into this.

.program maple_out
.side_set 2 opt

.define public MASK_A 0x1
.define public MASK_B 0x2
.define public MASK_AB 0x3

; must be even - minimum number of ticks per edge
.define public TICKS_PER_CLOCK 4
.define public HALF_TICKS (TICKS_PER_CLOCK / 2)

.wrap_target

; Stalls until first word; first word is how many bits this will send
; The following must be true about x: (x - 8) % 32 == 0 && x >= 40
out x, 32 side MASK_AB



; send out the start sequence
start_sequence:
; First, set pins as output and with A and B set HIGH
set pindirs MASK_AB side MASK_AB [TICKS_PER_CLOCK - 1]
; Bing A LOW for a cycle then toggle B LOW then HIGH 3 times
set y, 3 side MASK_B [TICKS_PER_CLOCK - 1]
start_b_toggle_loop:
nop side 0 [TICKS_PER_CLOCK - 1]
nop side MASK_B [TICKS_PER_CLOCK - 2]
jmp y-- start_b_toggle_loop
; Bring A back HIGH while reading the first bit
out y, 1 side MASK_AB [HALF_TICKS - 1]
; Then bring B LOW, decrement x, and start reading data
jmp x--, clock_a_data_b side MASK_A ; jmp only used to decrement x by 1 before continuing



; send out packet data
; x scratch register contains how many bits left to send
; y scratch register contains the current bit
clock_a_data_b:
jmp !y clock_a_data_b_zero
; else: fall through to clock_a_data_b_one

clock_a_data_b_one:
out y, 1 side MASK_A [HALF_TICKS - 1]
nop side MASK_AB [HALF_TICKS - 1]
jmp x-- clock_b_data_a side MASK_B
; jmp end_sequence ; should never reach here anyway (saves an instruction)

clock_a_data_b_zero:
out y, 1 side MASK_A [TICKS_PER_CLOCK - 1]
jmp x-- clock_b_data_a side 0 ; just need to decrement x
; jmp end_sequence ; should never reach here anyway (saves an instruction)

clock_b_data_a:
jmp !y clock_b_data_a_zero
; else: fall through to clock_b_data_a_one

clock_b_data_a_one:
out y, 1 side MASK_B [HALF_TICKS - 1]
nop side MASK_AB [HALF_TICKS - 1]
jmp x-- clock_a_data_b side MASK_A
jmp end_sequence

clock_b_data_a_zero:
out y, 1 side MASK_B [TICKS_PER_CLOCK - 1]
jmp x-- clock_a_data_b side 0
; Else: fall through to end sequence



; send out the end sequence
end_sequence:
nop side MASK_A [HALF_TICKS - 1]
nop side MASK_AB [TICKS_PER_CLOCK - 1]
nop side MASK_A [TICKS_PER_CLOCK - 1]
nop side 0 [TICKS_PER_CLOCK - 1]
nop side MASK_A [TICKS_PER_CLOCK - 1]
nop side 0 [TICKS_PER_CLOCK - 1]
nop side MASK_A [TICKS_PER_CLOCK - 1]
out y, 24 side MASK_AB [TICKS_PER_CLOCK - 1] ; last word only has crc byte to send; purge last 24 bits

; Make pins input again in case someone else starts sending right away
set pindirs 0

; Wait for IRQ to be handled before continuing
irq wait 0

.wrap

% c-sdk {
#include "hardware/gpio.h"
static inline void pio_maple_out_init(
    PIO pio, uint sm, uint prog_offs, uint sys_freq_khz, uint min_pulse_time_ns, uint pin_a)
{
    uint pin_b = pin_a + 1;
    pio_sm_config c = maple_out_program_get_default_config(prog_offs);
    sm_config_set_sideset_pins(&c, pin_a);
    sm_config_set_set_pins(&c, pin_a, 2); // just for set pindirs

    // Shift to left, autopull enabled, 32 bits at a time
    sm_config_set_out_shift(&c, false, true, 32);

    sm_config_set_clkdiv(
        &c, (sys_freq_khz * min_pulse_time_ns) / maple_out_TICKS_PER_CLOCK / 1000000.0);

    // Set this pin's GPIO function (connect PIO to the pad)
    pio_gpio_init(pio, pin_a);
    pio_gpio_init(pio, pin_b);
    gpio_set_dir_in_masked((1 << pin_a) | (1 << pin_b));
    gpio_set_pulls(pin_a, true, false);
    gpio_set_pulls(pin_b, true, false);
    // Pin direction starts as input
    pio_sm_set_consecutive_pindirs(pio, sm, pin_a, 2, false);

    // Load our configuration, and jump to the start of the program
    pio_sm_init(pio, sm, prog_offs, &c);
}

static inline void pio_maple_out_start(PIO pio, uint sm)
{
    pio_sm_restart(pio, sm);
    // Set the state machine running
    pio_sm_set_enabled(pio, sm, true);
}

static inline void pio_maple_out_stop(PIO pio, uint sm)
{
    pio_sm_set_enabled(pio, sm, false);
}
%}