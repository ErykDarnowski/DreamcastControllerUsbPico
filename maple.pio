
; maple_out notes:
; - It is up to the system to ensure open line before activating this (no overcurrent protection)
; - Since bytes are shifted out "to the left" in order to shift out the most significant bit of each
;   byte first, the most significant byte comes out first too. This means byte order will need to be
;   swapped before feeding into this.

.program maple_out
.side_set 2 opt

.define public MASK_A 0x1
.define public MASK_B 0x2
.define public MASK_AB 0x3

; must be even - minimum number of ticks per edge
; 3 bits are used for sideset, so 4 is the max here
; The logic in this file is tightly coupled to the value of 4 (do not change)
.define public DOUBLE_PHASE_TICKS 4
.define public SINGLE_PHASE_TICKS (DOUBLE_PHASE_TICKS / 2)

.wrap_target
maple_out_start:

; Stalls until first word; first word is how many bits this will send
; The following must be true about x: (x - 8) % 32 == 0 && x >= 40
out x, 32 side MASK_AB



; send out the start sequence
start_sequence:
; First, set pins as output and with A and B set HIGH
set pindirs MASK_AB side MASK_AB [DOUBLE_PHASE_TICKS - 1]
; Bing A LOW for a cycle then toggle B LOW then HIGH 3 times
set y, 3 side MASK_B [DOUBLE_PHASE_TICKS - 1]
start_b_toggle_loop:
nop side 0 [DOUBLE_PHASE_TICKS - 1]
nop side MASK_B [DOUBLE_PHASE_TICKS - 2]
jmp y-- start_b_toggle_loop
; Bring A back HIGH and decrement x in preparation of the first bit
jmp x--, first_clock_a_data_b side MASK_AB

; Don't want to bring B low unless the first bit is 0, so this is a special check
first_clock_a_data_b:
out y, 1 side MASK_AB
jmp !y, clock_a_data_b_zero side MASK_AB
jmp first_clock_a_data_b_one side MASK_AB



; send out packet data
; x scratch register contains how many bits left to send
; y scratch register contains the current bit
clock_a_data_b:
out y, 1 side MASK_A [SINGLE_PHASE_TICKS - 2]
jmp !y clock_a_data_b_zero
; else: fall through to clock_a_data_b_one

clock_a_data_b_one:
nop side MASK_AB [SINGLE_PHASE_TICKS - 1]
first_clock_a_data_b_one:
jmp x-- clock_b_data_a side MASK_B [SINGLE_PHASE_TICKS - 1]
; jmp end_sequence ; should never reach here anyway (saves an instruction)

clock_a_data_b_zero:
nop side MASK_A [SINGLE_PHASE_TICKS - 1]
jmp x-- clock_b_data_a side 0 [SINGLE_PHASE_TICKS - 1] ; just need to decrement x
; jmp end_sequence ; should never reach here anyway (saves an instruction)

clock_b_data_a:
out y, 1 side MASK_B [SINGLE_PHASE_TICKS - 2]
jmp !y clock_b_data_a_zero
; else: fall through to clock_b_data_a_one

clock_b_data_a_one:
nop side MASK_AB [SINGLE_PHASE_TICKS - 1]
jmp x-- clock_a_data_b side MASK_A [SINGLE_PHASE_TICKS - 1]
jmp end_sequence ; extra tick added here which can't be helped

clock_b_data_a_zero:
nop side MASK_B [SINGLE_PHASE_TICKS - 1]
jmp x-- clock_a_data_b side 0 [SINGLE_PHASE_TICKS - 1]
; Else: fall through to end sequence



; send out the end sequence
end_sequence:
out y, 24 side MASK_A [SINGLE_PHASE_TICKS - 1] ; last word only has crc byte to send; purge last 24 bits
nop side MASK_AB [DOUBLE_PHASE_TICKS - 1]
nop side MASK_A [DOUBLE_PHASE_TICKS - 1]
nop side 0 [DOUBLE_PHASE_TICKS - 1]
nop side MASK_A [DOUBLE_PHASE_TICKS - 1]
nop side 0 [DOUBLE_PHASE_TICKS - 1]

; Wait for IRQ to be handled before continuing
irq wait 0 rel side MASK_A

; Allow the application to transition AB back HIGH when it's ready to "submit" the data.
; See MapleOutStateMachine::stop()

.wrap

% c-sdk {
#include "hardware/gpio.h"
#include "hardware/pio.h"

#define MAPLE_OUT_PIO pio0

class PioProgram
{
    public:
        inline PioProgram(pio_hw_t* pio, const pio_program_t *program) :
            mPio(pio),
            mProgram(program),
            mProgramOffset(pio_add_program(pio, program))
        {}

        pio_hw_t* const mPio;
        const pio_program_t* const mProgram;
        const uint mProgramOffset;
};

class MapleOutStateMachine
{
    public:
        inline MapleOutStateMachine(uint sys_freq_khz, uint ns_per_bit, uint pin_a) :
            mProgram(getMapleOutProgram()),
            mPinA(pin_a),
            mPinB(pin_a + 1),
            mMaskAB(3 << pin_a),
            mSmIdx(pio_claim_unused_sm(mProgram.mPio, true))
        {
            // Initialize the two pins as inputs with pullups
            gpio_set_dir_in_masked(mMaskAB);
            gpio_set_pulls(mPinA, true, false);
            gpio_set_pulls(mPinB, true, false);

            pio_sm_config c = maple_out_program_get_default_config(mProgram.mProgramOffset);
            sm_config_set_sideset_pins(&c, mPinA);
            sm_config_set_set_pins(&c, mPinA, 2); // just for set pindirs

            // Shift to left, autopull enabled, 32 bits at a time
            sm_config_set_out_shift(&c, false, true, 32);

            sm_config_set_clkdiv(
                &c, (sys_freq_khz * (ns_per_bit / 3 * 2)) / maple_out_DOUBLE_PHASE_TICKS / 1000000.0);

            // Load our configuration, and jump to the start of the program
            pio_sm_init(mProgram.mPio, mSmIdx, mProgram.mProgramOffset, &c);
        }

        inline void start() const
        {
            // Reset pointers
            pio_sm_clear_fifos(mProgram.mPio, mSmIdx);
            pio_sm_restart(mProgram.mPio, mSmIdx);
            pio_sm_clkdiv_restart(mProgram.mPio, mSmIdx);
            pio_sm_exec(mProgram.mPio, mSmIdx, pio_encode_jmp(mProgram.mProgramOffset));
            // Pin direction starts as input
            pio_sm_set_consecutive_pindirs(mProgram.mPio, mSmIdx, mPinA, 2, false);
            // Set this pin's GPIO function (connect PIO to the pad)
            pio_gpio_init(mProgram.mPio, mPinA);
            pio_gpio_init(mProgram.mPio, mPinB);
            // Set the state machine running
            pio_sm_set_enabled(mProgram.mPio, mSmIdx, true);
        }

        inline void stop() const
        {
            pio_sm_set_enabled(mProgram.mPio, mSmIdx, false);
            // Reset the pins' function to standard I/O, transitioning back HIGH before setting to input
            gpio_set_mask(mMaskAB);
            gpio_set_dir_out_masked(mMaskAB);
            gpio_set_function(mPinA, GPIO_FUNC_SIO);
            gpio_set_function(mPinB, GPIO_FUNC_SIO);
            gpio_set_dir_in_masked(mMaskAB);
        }

    private:
        inline static const PioProgram& getMapleOutProgram()
        {
            static const PioProgram program(MAPLE_OUT_PIO, &maple_out_program);
            return program;
        }

    public:
        const PioProgram& mProgram;
        const uint mPinA;
        const uint mPinB;
        const uint mMaskAB;
        const uint mSmIdx;
};

%}

.program maple_in

; Wait for start sequence
wait_start:

set y, 3
b_toggle_low_loop:
jmp pin wait_start ; A should not be high yet
; `mov x, pins` wouldn't work because I just want the first 2 pins
mov osr, pins ; copy pin values into output shift register
out x 2 ; put A and B into register x (should either be 0b01 or 0b00)
jmp x-- b_toggle_low_loop ; keep waiting if B is high
; else: fall through

b_toggle_high_loop:
jmp pin wait_start ; A should not be high yet
mov osr, pins ; copy pin values into output shift register
out x 2 ; put A and B into register x (should either be 0b01 or 0b00)
jmp !x b_toggle_high_loop ; keep waiting if b is low
jmp y-- b_toggle_low_loop ; toggle detected; decrement do another wait until 0
; else: fall through

; Wait for A to go back high
wait_for_a_high:
jmp pin data_start ; once A goes HIGH, start data sequence
mov osr, pins ; copy pin values into output shift register
out x 2 ; put A and B into register x (should either be 0b01 or 0b11)
jmp !x wait_start ; if both A and B go low before A goes HIGH, then this is not a standard start sequence
jmp wait_for_a_high ; keep sampling

data_start:
; The first IRQ tells application that start sequence detected
irq set 0 rel

; Wait for A to go low then fall through to first end detect phase (which should cause sample of B)
wait 0 pin 0


.wrap_target
data_loop:

; wait for B to toggle HIGH then LOW or for A go LOW
set y, 1
end_detect_b_toggle:
mov osr, pins ; copy pin values into output shift register
out x 1
jmp !x sample_b_from_osr ; if A went low before B went high, then sample B now
out x 1
jmp !y end_detect_b_to_low ; if y is 0 then we are waiting for B to be low
end_detect_b_to_high:
jmp !x end_detect_b_toggle ; if B is still LOW, try again
jmp y-- end_detect_b_toggle ; B just went HIGH, so decrement y and sample again
end_detect_b_to_low:
jmp x-- end_detect_b_toggle ; if B is still HIGH, try again
; otherwise, fall through to next end detect phase

; Warning: the full end sequence is not sampled for simplicity
; Either end is actually there or there was a glitch (rely on len and CRC of packet data in that case)
end_detected:
;push ; make sure the crc is pushed out (this is done externally by the stop() function)
; Wait for IRQ to be handled before continuing (application should kill the state machine soon after this)
irq wait 0 rel


sample_b_from_osr:
in osr 1 ; shift in B value

sample_a:
; wait for B to be high
wait 1 pin 1
; wait for B to be low
wait 0 pin 1
; shift in A value
in pins 1

; wait for A to be high
wait 1 pin 0

.wrap

% c-sdk {
#include "hardware/gpio.h"
#include "hardware/pio.h"

#define MAPLE_IN_PIO pio1

class MapleInStateMachine
{
    public:
        inline MapleInStateMachine(uint pin_a) :
            mProgram(getMapleInProgram()),
            mPinA(pin_a),
            mPinB(pin_a + 1),
            mMaskAB(3 << pin_a),
            mSmIdx(pio_claim_unused_sm(mProgram.mPio, true))
        {
            // Initialize the two pins as inputs with pullups
            gpio_set_dir_in_masked(mMaskAB);
            gpio_set_pulls(mPinA, true, false);
            gpio_set_pulls(mPinB, true, false);

            pio_sm_config c = maple_in_program_get_default_config(mProgram.mProgramOffset);
            sm_config_set_in_pins(&c, mPinA);

            // jmp pin checks pin A
            sm_config_set_jmp_pin(&c, mPinA);

            // Shift to right, autopull disabled, 32 bits at a time
            sm_config_set_out_shift(&c, true, false, 32);
            // Shift to left, autopush enabled, 32 bits at a time
            sm_config_set_in_shift(&c, false, true, 32);

            // Sample as fast as possible
            sm_config_set_clkdiv(&c, 1);

            // Load our configuration, and jump to the start of the program
            pio_sm_init(mProgram.mPio, mSmIdx, mProgram.mProgramOffset, &c);
        }

        inline void start() const
        {
            // Reset pointers
            pio_sm_clear_fifos(mProgram.mPio, mSmIdx);
            pio_sm_restart(mProgram.mPio, mSmIdx);
            pio_sm_clkdiv_restart(mProgram.mPio, mSmIdx);
            pio_sm_exec(mProgram.mPio, mSmIdx, pio_encode_jmp(mProgram.mProgramOffset));
            // Pin direction starts as input
            pio_sm_set_consecutive_pindirs(mProgram.mPio, mSmIdx, mPinA, 2, false);
            // Set this pin's GPIO function (connect PIO to the pad)
            pio_gpio_init(mProgram.mPio, mPinA);
            pio_gpio_init(mProgram.mPio, mPinB);
            // Set the state machine running
            pio_sm_set_enabled(mProgram.mPio, mSmIdx, true);
        }

        inline void stop() const
        {
            pio_sm_set_enabled(mProgram.mPio, mSmIdx, false);

            // Push out the CRC (0x8020 = push block)
            pio_sm_exec_wait_blocking(mProgram.mPio, mSmIdx, 0x8020);

            // Reset the pins' function to standard I/O with pullups
            gpio_set_function(mPinA, GPIO_FUNC_SIO);
            gpio_set_function(mPinB, GPIO_FUNC_SIO);
            gpio_set_dir_in_masked(mMaskAB);
        }

    private:
        inline static const PioProgram& getMapleInProgram()
        {
            static const PioProgram program(MAPLE_IN_PIO, &maple_in_program);
            return program;
        }

    public:
        const PioProgram& mProgram;
        const uint mPinA;
        const uint mPinB;
        const uint mMaskAB;
        const uint mSmIdx;
};

%}
